## 정당성의 증명: 탐욕적 선택 속성
- 정당성 증명은 많은 경우 일정한 패턴을 가진다
- 동적 계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택해도 최적해를 구할 수 있다는 속성을 증명해야 함.
- 탐욕적 선택 속성(greedy choice property): 어떤 알고리즘에 이 속성이 성립할 경우, 우리가 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길 중 하나
- 위 문제의 경우 탐욕적 선택 속성이 성립된다면 아래와 같은 말
    - 가장 종료 시간이 빠른 회의(Smin)를 포함하는 최적해가 반드시 존재한다.
    - S의 최적해 중 Smin을 포함하지 않는 답이 있다고 가정
    - 이 답은 서로 겹치지 않는 회의의 목록인데, 이 목록에서 첫번째로 개최되는 회의를 지우고 Smin을 대신 추가해서 새 목록 생성.
    - Smin은 S에서 가장 일찍 끝나는 회의이기 때문에 지워진 회의는 Smin보다 일찍 끝날 수 없음
    - 따라서 2번째 회의와 Smin이 겹치는 일은 없으며, 새로 만든 목록도 최적 해 중 하나가 됨.
    - 따라서 항상 Smin을 포함하는 최적해는 존재한다.
## 최적 부분 구조
- 항상 최적의 선택을 내리는 것이 전체 문제의 최적해를 구하는 것은 아닐 수 있다
    - 첫번째 선택 후 남은 문제는 최적이 아닌 방법으로 풀어야 하는 경우
- 최적 부분 구조(optimal substructure): 부분 문제의 최적해에서 전체 문제의 최적해를 만들 수 있음을 보여야 한다.
- 대부분은 성립함.
## 구현
- 모든 회의 목록을 저장해 두고, 한 회의를 선택할 때마다 겹치는 회의들을 모두 제거한다.
    - 시간 복잡도: 목록을 배열에 저장해야 한다면 O(N^2)가 되어 오래 걸린다.
    - 따라서, 모든 회의를 종료 시간의 오름차순으로 정렬해 둔다
- 배열의 첫번째 회의는 무조건 선택해도 된다.
- 그 후 겹치는 회의를 지우지 말고, 정렬된 배열을 순회하며 첫번째 회의과 겹치는 않는 회의를 찾는다.
    - 정렬되어 있기 때문에, 겹치는 회의를 찾자마자 나머지를 보지 않고 선택해도 된다.
```cpp
코드 10.1 회의실 예약 문제를 해결하는 탐욕적 알고리즘
// 각 회의는 [begin, end] 구간 동안 회의실을 사용한다.
int n;
int begin[100], end [100];
int schedule() {
    //일찍 끝나는 순서대로 정렬한다.
    vector<pair<int,int>> order;
    for(int i = 0; i < n; ++i)
        order.push_back(make_pair(end[i], begin[i]))
    sort(order.begin(), order.end());
    //earlist: 다음 회의가 시작할 수 있는 가장 빠른 시간
    //selected: 지금까지 선택한 회의의 수
    int earliest = 0, selected = 0;
    for(int i = 0l i < order.size(); ++i) {
        int mettingBegin = order[i].second, meetingEnd = order[i].first;
        if(earliest <= meetingBegin) {
            //earliest를 마지막 회의가 끝난 시간 이후로 갱신한다.
            earliest = meetingEnd;
            ++selected;
        }
    }
    return selected;
}
```
- 시간복잡도: O(N * log N)
- 각 단계에서 회의를 할 때 남은 다른 회의들은 전혀 신경 쓰지 않는다.
- 지금 당장 가장 일찍 끝나는 회의만을 선택함
## 난 동적 계획법으로 풀었는데?
- 회의들을 끝나는 시간이 증가하는 순으로 정렬, 다음과 같은 부분 문제를 푼다
    - schedule(idx) = meeting[idx] 혹은 그 이전에 끝나는 회으들 중 선택할 수 있는 최대 회의의 수
- schedule(idx)는 meeting[idx]를 선택할지 여부를 결정한다.
    - 선택하지 않을 경우 최적해: schedule(idx -1)
    - 선택할 경우: 1 + schedule(before[idx]) (before[idx] = idx번 회ㅡ이가 시작하기 전 끝나는 회의들 중 마지막 회의의 번호)
- 시간복잡도: before[] 를 만드는ㄴ데 O(N * logN), schedule()수행은 2 O(N)이므로 탐욕법과 다를 것이 없음
- 대부분 탐욕법으로 가능하면, 동적 계획법으로도 가능
    - 탐욕법은 지금 한 단계만 고려해도 답을 찾을 수 있다는 의미, 동적계획법은 모든 단계를 고려해야 한다.
- 동적계획법이 메모리나 시간이 과도하게 크다.

## 예제: 출전 순서 정하기(문제ID: MATCHORDER, 난이도: 하)
- n 명의 코더, 1:1경기를 벌여 더 많은 승리를 가져가면 우승. 각 선수의 실력은 레이팅(rating)으로 표현, 높은 경우 승리.
- 상대팀 출전선수 출전순서를 아는 경우, 어느 순서대로 내보내야 승수 최대화 가능한지
- p.371  

## 무식하게 풀 수 있을까? 
- n명의 선수가 있으니 n!개의 정답 존재. 다 세는게 어렵다.
## 그렇다면 동적 계획법은 어떨까?
- order(taken) = 각 한국팀 선수를 이미 순서에 추가했는지의 여부가 taken에 주어질 때, 남은 선수들을 적절히 배치해서 얻을 수 있는 최대 승수
- taken에 포함된 true의 수를 세면 이번에 선택할 선수가 러시아팀의 어떤 선수와 경기하게 되는지도 알 수 있으니 다른 인자 필요없음
- 시간 복잡도: O(N * 2^n)
## 탐욕적 알고리즘의 구상
- 간단한 입력을 손으로 풀어 보며 패턴을 찾자.
- 상대방 선수를 이길 수 있는 한국 선수가 있으면 그 중 레이팅이 가장 낮은 선수를 상대방 선수와 경기
- 상대방 선수를 이길 수 있는 한국 선수가 없으면 남은 선수 중 가장 레이팅이 낮은 선수와 경기 
## 탐욕적 선택 속성 증명
- 항상 우리가 하는 선택을 포함하는 최적해가 존재함을 증명한다
    - 각 경기에 대해 이 경기를 질 수밖에 없는 경우, 그리고 이 경기를 이길 수 있는 경우로 나누어 우리의 선택이 옳다는 것을 보인다.
- 이 경기를 질 수 밖에 없는 경우
    - 상대팀 선수가 모든 우리 팀 선수보다 레이팅이 높으면 질 수밖에 없음
    - 가장 레이팅이 낮은 선수 A 대신 선수 B를 내보내는 최적해가 있다고 가정
    - p.373 위 그림ㅔ373
    - 최적해에서 두 선수의 순서를 바꾸면 이번 경기는 어차피 질 테지만, A를 상대했던 선수 x는 레이팅이 더 높은 선수를 상대하게  됨.
    - 따라서 승수가 줄어들 일은 없고, 이 경기에서 A를 내보내는 최저갷가 존재함을 알게 됨.
- 이 경기를 이길 수 있는 경우
    - 상대팀 선수보다 레이팅이 높거나 같은 우리 선수가 있다면 이 경기를 승리할 수 있음
    - 승리할 수 있는 선수 중 레이팅이 가장 낮은 A 대신 레이팅이 더 높은 B를 내보내는 최적해가 있다고 가정
    - p.373 아래 그림
    - 최적해에서 두 선수의 순서를 바꾸면 이번 경기는 승리할테지만, A를 상대했던 선수 x는 레이팅이 더 높은 선수를 상대하게 됨
    - 같은 전개로 이 순서 또한 최적해이다.
- 탐욕적 선택 속성 증명 패턴
    - 1. 우리가 선택한 방법을 포함하지 않는 최적해의 존재를 가정
    - 2. 이것을 적절히 조작하여 우리가 선택한 방법을 포함하는 최적해를 만들어 냄
## 최적 부분 구조 증명
- 첫 번째 경기에 나갈 선수 선택하고 나면 남은 선수들을 경기에 배정하는 부분 문제를 얻음
- 이 때 남은 경기에서도 당연히 최다승을 얻는 것이 좋으니 최적 부분 구조도 성립함을 알 수 있음
## 구현
- 출전하지 않은 선수들의 레이팅을 이진 검색 트리 multiset<int>에 저장
- 이로 인해 이길 수 있는 가장 레이팅이 낮은 선수를 찾는 작억과 선택한 선수의 레이팅을 삭제하는 작업 모두 O(logN)에 수행 가능
- 전체 시간 복잡도: O(N * logN)
```cpp
코드 10.2 출전 순서 정하기 문제를 해결하는 탐욕적 알고리즘
int order(const vector<int>& russian, const vector<int>& korean){
    int n = russian.size(), wins = 0;
    //아직 남아있는 선수들의 레이팅
    multisetint> ratings(korean.begin(), korean.end());
    for(int rus = 0; rus < n; ++rus){
        //가장 레이팅이 높은 한국 선수가 이길 수 없는 경우
        //가장 레이팅이 낮은 선수와 경기시킨다
        if(*ratings.rbegin() < russian[rus])
            ratings.erase(ratings.begin());
        //이 외의 경우 이길 수 있는 선수 중 가장 레이팅이 낮은 선수와 경기시킨다
        else {
            ratings.erase(ratings.lower_bound(russian[rus]));
            ++wins;
        }
    }  
}
```
## 탐욕적 알고리즘 레시피
- 1. 문제의 답을 만드는 과정을 여러 조각으로 나눈다
- 2. 각 조각마다 어떤 우선순위로 선택을 내려야 할지 결정한다.
- 3. 방식이 결정되면 두 가지 속성을 증명해본다
    - a. 탐욕적 선택속성: 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재함을 보인다.
    - b. 최적 부분 구조: 각 단계에서 항상 최적의 선택만을 했을 때 전체 최적해를 구할 수 있는지 여부를 증명한다
# 10.2 문제: 도시락 데우기 (문제ID: LUNCHBOX, 난이도:하)
- n명의 사람이 각기 다른 데우는 시간을 가진 n 개의 도시락을 먹는데 걸리는 시간을 최소화하는 계획.
- 첫번째 도시락을 데우기 시작할 때부터 모든 사람이 도시락을 다 먹을때까지 걸리는 시간
- 어느 순서로 데워야 가장 빨리 점심시간을 마칠 수 있는지
# 10.3 풀이: 도시락 데우기
## 최소화해야할 값
- p.377
## 탐욕적 알고리즘의 구상
- 간단히 생각해 보기 위해 모든 도시락을 먹는데 같은 시간 C가 걸린다고 가정
- 어떤 순서로 도시락을 데우건 점심시간의 길이는 모든 도시락을 데우는 시간과 도시락 하나를 먹는 시간의 합 C + ∑Mi 
- 좀 더 복잡한 문제를 보면, n -1 개의 돈까스 도시락 사이에 샤브샤브 도시락이 딱 하나 있다고 가정
- 샤브샤브 도시락은 먹는데 시간이 더 오래 걸리면, 먼저 데우는 게 나음
- 위 예시들로서 데우는 시간과는 관계없이 먹는데 오래 걸리는 도시락부터 먹는게 정답일 것 같음. 
## 탐욕적 선택 속성 증명
- 먹는데 가장 오래 걸리는 샤브샤브 도시락을 제일 먼저 데우는 최적해가 반드시 하나는 있음을 보여준다.
- 돈까스 도시락을 제일 먼저 데우는 최적해가 존재한다고 가정
- p.378
- 이 최적해에서 둘의 위치를 바꾼 뒤 이것도 최적해가 된다는 것을 보여주자
- 돈까스와 샤브샤브 순서를 바꿔도 x + 1번 이후의 도시락들 입장에선 다를 것이 없다.
    - 어느 순서로 데우건 이 도시락들이 기다려야 하는 시간은 같기 때문
- 따라서 먹데 걸리는 시간이 달라지는 도시락들은 0~x번까지의 도시락.
- 따라서 나머지 무시하고 이들만을 고려한다.
- p.379_1
- 가장 마지막에 식사가 끝나는 도시락은 항상 샤브샤브라는 것을 주목
    - 가장 늦게 데우며 먹는데도 오래 걸리기 때문
- 샤브샤브를 먹는 사람이 식사가 끝나는 시간 = 0~x번 도시락 데우는 시간 + 샤브샤브 먹는데 걸리는 시간
    - p.379_2
- 이제 남은 도시락들 순서들 자유롭게 바꾼다고 가정하면,
- 어떤 도시락도 다 먹는데 걸리는 시간이 앞에서 설명한 값 max를 초과할 수는 없음
- 이 순서에서 y번째 도시락을 먹는데 걸리는 시간은 다음과 같음
    - p.379_3
- y번째 도시락은 샤브샤브보다 먹는 데 오래 걸리지 않고,
    - p.379_4
- 더 오래 기다려야 하는 것도 아니기 때문에
    - p.379_5
- 이 식이  max보다 클 수는 없다
- 따라서 샤브샤브와 돈까스의 순서를 서로 바꾼 답이 최적해보다 나빠질 수는 없고, 따라서 이 답도 최적해이다.
## 최적 부분 구조 증명
- 첫 번째 도시락을 정하면 나머지 도시락을 배치해야 한다.
- 이 때 각 도시락을 다 먹기까지 걸리는 시간은 첫 번째 도시락을 데우는 시간만큼 지연되지만,
- 남은 도시락들에 대해서도 가장 늦게 다 먹는 시간을 최소화해서 손해 볼 것은 없다.
- 따라서 매 단계마다 최적의 선택을 해도 상관없다.
## 구현
```cpp
코드 10.3 도시락 데우기 문제를 해결하는 탐욕적 알고리즘
int n, e[MAX_N], m[MAX_N];
int heat() {
    // 어느 순서로 데워야 할지를 정한다.
    vector<pair<int,int>> order;
    for(int i = 0; i < n; ++i)
        order.push_back(make_pair(-e[i], i));
    sort(order.begin(), order.end());
    //해당 순서대로 데워먹는 과정을 시뮬레이션한다.
    int ret = 0; beginEat = 0;
    for(int = 0; i < n; ++i){
        int box = order[i].second;
        beginEat += m[box];
        ret = max(ret, beginEat + e[box]);
    }
    return ret;
}
```

# 10.4 문제: 문자열 합치(문제ID: STRJOIN, 난이도: 중)
- C 문제점: 문자열 변수형 지원하지 않는다. 문자열 길이를 쉽게 알 수 없어 문제 발생함
- 문자열을 조작하는 함수들의 동작 시간이 불필요하게 커지는 점이 있음.
- strcat()은 문자열 dest 뒤에 src를 부이는 함수, 실행화정에서 반복문을 두 문자열의 길이를 합한만큼 수행해야 함.
- 위 함수를 이용해 두 문자열을 합치는 비용이 두 문자열의 길이의 합이라고 해보자.
```cpp
void strcat(char* dest, const char* src){
    // dest의 마지막 위치를 찾는다.
    while(*dest) ++dest;
    while(*src) *(dest++) = *(src++);
    //문자열의 끝을 알리는 ₩0을 추가한다.
    *dest = 0;
}
```
- 이 함수를 이용해 n개의 문자열을 순서와 상관없이 합쳐서 한 개의 문자열로 만들고 싶을 때,
- n개의 문자열들의 길이가 주어질 때 필요한 최소 비용을 찾는 프로그램 작성.

# 10.5 풀이: 문자열 합치기
## 그림으로 그려보기
- p.383 10.2 맨위 그림
## 탐욕적 알고리즘의 구상
- 한 문자열이 전체 비용에 영향
    - 문자열을 병합할 때마다 병홥되는 문자열들의 총 길이가 전체 비용에 더해짐.
    - 이 때 합쳐진 결과 문자열의 길이를 원래 입력에 주어졌던 문자열별로 나눌 수 있음.
- 한 물자열로 인해 발생하는 총 비용은 이 문자열이 병합되는 횟수에 문자열의 길이를 곱한 것이라는 사실을 알 수 있음.
- 문자열이 길면 길수록 트리의 윗부분에 가깝고, 짧으면 짧을수록 아래 쪽으로 내려가야 한다는 직관을 얻을 수 있다.
## 알고리즘 설계하기
- 탐욕적 알고리즘은 문제의 답을 여러 조각으로 나눠 한 조각마다 한 가지의 선택을 한다.
    - 이 문제에서는 한 조각마다 두 문자열을 합치는 것으로 한다.
    - 문자열 목록에서 두 개를 골라내고, 이들을 합친 뒤 다시 문자열 목록에 추가하는 과정을 반복
    - 트리를 밑에서부터 만들어나가는 접근
- 문자열이 길면 길수록 트리의 위쪽에 있다는 것이 유리하다는 점을 돌이켜보면 '항상 가장 짧은 두 개의 문자열을 합치는 것이 어떨까'
- p.384 그림10.3
## 정당성 증명
- 탐욕적 선택 속성 증명
    - 매단계마다 가장 짧은 두 문자열을 합치는 일을 반복하는 이 선택이 최적해임을 증명하려면
    - 이 선택을 포함하는 최적해가 반드시 있음을 보여주면 된다.
- 문제의 최적해가 가장 짧은 두 개의 문자열 a와 b를 서로 처음에 합치지 않은 형태라고 가정
- 이 최적해는 그림 10.4(a)나 (b) 두 가지 형태 중 하나.
- 각 경우를 변형해 항상 a와 b를 처음에 합치는 최적해도 존재함을 증명
- a와 b가 최초로 합쳐지는 문자열을 X라고 함.
- 그림에서 원으로 표현된 문자열들의 위치를 서로 바꾼다고 해도 트리의 X부분은 변하지 않음, 따라서 X까지 문자열을 합치는데 필요한 비용만을 신경씀.
- p.385 맨위
- 그림 10.4(a)에 표시된 경우: a와 b가 각각 다른 문자열과 합쳐진 뒤 X에서 하나로 합쳐지는 경우
    - a와 b는 가장 짧은 두 개의 문자열이므로 x와 y의 길이는 a와 b와 같거나 더 길 수 밖에 없음
    - 이 때 a와 b가 X에서 몇 단계나 떨어져 있나를 비교
        - 1. 거리가 같은 경우: x와 b의 위치를 서로 바꿔도 답은 변하지 않음
        - 2. 거리가 다를 경우: a, b중 X에 더 가까운 쪽이 더 먼 쪽과 합쳐지도록 옮겨감.
            - 그림처럼 a가 b보다 멀리 떨어져 있다면 b와 x의 위치를 바꾼다.
            - x가 병합되는 횟수는 더 줄어들고, b가 병합되는 횟수는 그만큼 늘어난다
            - 그러나 x의 길이는 항상 b이상이기 때문에 결과적으로는 항상 이득이거나 같은 비용이다.
- 그림 10.4(b)에 표시된 경우: a가 다른 문자열과 합쳐지고, 이 문자열이 결과적으로 b와 합져지는 경우.
    - x를 b와 바꾸면 x가 병합되는 횟수는 줄어들고, b가 병합되는 횟수는 늘어난다.
    - 그러나 x의 길이는 항상 b 이상이기 때문에 결과적으로는 항상 이득이거나 같은 비용이다.
## 최적 부분 구조
- 두 문자열을 ㅎ바치고 나면 남은 문자열들 또한 항상 최소 비용을 써서 합치는 것이 이득이므로 자명하게 성립.
## 구현
- 문자열 길이의 목록을 유지하면서 최소 길이를 골라내고, 새 길이를 추가하는 과정을 반복
- 우선순위 큐를 통해 O(logN)으로 구현 가능.
```cpp
코드 10.4 문자열 합치기 문제를 해결하는 탐욕적 알고리즘
// 문자열들의 길이가 주어질 때 하나로 합치는 최소 비용을 반환한다.
int concat(const vector<int>& lengths){
    //최소 큐를 선언한다
    priority_queue<int, vector<int>, greater<int> pq;
    for(int i = 0; i < lengths.size(); ++i)
        pq.push(lengths[i]);
    int ret = 0;
    // 원소가 하나 이상 남은 동안 반복한다.
    while(pq.size() > 1){
        // 가장 짧은 문자열 두 개를 찾아서 합치고 큐에 넣는다.
        int min1 = pq.top(); pq.pop();
        int min2 = pq.top(); pq.pop();
        pq.push(min1 + min2);
        ret += min1 + min2;
    }
    return ret;
}
```
## 이론적 배경: 허프만 코드
- 호프만 코드: 가변 길이 인코딩(variable-length encoding) 테이블을 만드는 방법으로 여러 압축 알고리즘에 사용
- 가빈 길이 인코딩: 원문의 각 글자를 서로 길이가 다를 수 있는 비트 패턴으로 바꿈으로써 원문의 길이를 줄이는 방법
    - 에시: H -> 01, E -> 001, I -> 1, O -> 000 으로 코드를 정하면 
    - HELLO -> 0100111000 우로 압축됨.
    - 더 자주 출현하는 글자는 짧은 패턴, 반대인 경우 긴 패턴을 배당할 필요
- 허프만 코드는 원문에 출현하는 글자들의 빈도가 주어질 때 예상 길이를 최소화하는 비트 패턴을 만들어 줌.
- p.387 그림 10.5
- 각 사각형에서는 0과 1 두 개의 간선이 뻗어나감.
- 각 글자를 나타내는 인코딩은 내려가면서 만나는 간선들의 번호를 붙인 것.
- 이 때 우리는 각 글자에 대해 출현 확률과 코드의 길이를 곱한 것의 합을 최소화해야 함.
- 출현 확률이 문자열 길이로 바뀐 것일뿐 윗 문제와 똑같다.
