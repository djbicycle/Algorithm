# 문제 해결 개관
## 2.1 도입
## 2.2 문제 해결 과정
- 1. 문제를 읽고 이해한다.
- 2. 문제를 익숙한 용어로 재정의한다
- 3. 어떻게 해결할지 계획을 세운다
- 4. 계획을 검증한다.
- 5. 프로그램으로 구현한다.
- 6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.
### 1단계: 문제를 읽고 이해하기
- 잘못 읽지 않도록 한다.
### 2단계: 재정의와 추상화
- 어느 저도의 본질만을 남겨두고 축약하여 다루기 쉽게 표현한다.
### 3단계: 계획 세우기
- 사용할 알고리즘과 자료구조 선택
- 문제 해결에서 가장 중요한 단계
### 4단계: 계획 검증하기
- 알고리즘의 효율성 분석, 알고리즘의 정당성 증명 등을 통해 요구조건을 정확히 수행하는지 증명한다.
### 5단계: 계획 수행하기
- 정확하고 효율적으로 프로그램 작성한다.
### 6단계: 회고하기
- 코드와 함께 자신의 접근방법, 경험, 오답노트 등을 기록으로 남긴다.
- 다른 사람의 코드를 보고 공부한다.
### 문제를 풀지 못할 때
- 일정시간 고민해도 모르면 다른 사람 것 참조.
- 단, 반드시 복기를 동반한다.
## 2.3 문제 해결전략
### 체계적인 접근을 위한 질문들
- 비슷한 문제를 풀어본 적이 있던가
- 단순한 방법에서 시작할 수 있을까
- 내가 문제를 푸는 과정을 수식화할 수 있을까
- 문제를 단순화할 수 없을까
- 그림으로 그려볼 수 있을까
- 수식으로 표현할 수 있을까
- 문제를 분해할 수 있을까
- 뒤에서부터 생각해서 문제를 풀 수 있을까
- 순서를 강제할 수 있을까
- 특정 형태의 답만을 고려할 수 있을까

# 코딩과 디버깅에 대하여
## 3.1 도입: 코딩의 중요성을 간과하지 말라
- 간결하고 일관되게 코드 스타일을 다듬으려고 노력해라.
## 3.2 좋은 코드를 짜기 위한 원칙
- 간결한 코드를 작성하기
  - 전역변수 쓰기(프로그래밍 대회 한정)
  - 매크로 사용(C++)
- 적극적으로 코드 재사용하기
  - 같은 코드가 반복되면 모듈화
- 표준 라이브러리 공부하기
- 항상 같은 형태로 프로그램을 작성하기
- 일관적이고 명료한 명명법 사용하기
- 모든 자료를 정규화해서 저장하기
- 코드와 데이터를 분리하기
## 3.3 자주 하는 실수
- 산술 오버플로
- 배열 범위 밖 원소 접근
- 일관되지 않은 범위 표현 방식 사용하기
    - 열린 구간, 닫힌 구간, 반 열린 구간 같은 것들
- Off-by-one 오류
    - 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드들의 오류
- 컴파일러가 잡아주지 못하는 상수 오타
- 스택 오버플로
    - 사용하는 환경의 스택 허용량에 대해 알아두어야 함.
- 다차원 배열 인덱스 순서 바꿔 쓰기
- 잘못된 비교 함수 작성
- 최소, 최대 예외 잘못 다루기
- 연산자 우선순위 잘못 쓰기
- 너무 느린 입출력 방식 선택
- 변수 초기화 문제
## 3.4 디버깅과 테스팅
- 디버깅에 관하여
    - 대회에서는 누이 더 빠를 수 있음
    - 재귀호출, 중복 반복문은 디버거로 하는게 적당하지 않음
- 디버거 없어 프로그램의 버그를 찾는 연습을 하라
    - 작은 입력에 대해 제대로 실행되나 확인
    - 단정문(assertion)을 쓴다.
          - 주어진 조건이 거짓을 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문
    - 프로그램의 계산 중간 겨로가를 출력한다
- 테스트에 관하여
    - 스캐폴딩 활용: 뼈대를 잡기 위해 임시로 사용하는 코드.
          - 작은 입력을 여러 개 수행해본다.
## 3.5 변수 범위의 이해
- 산술 오버플로: 자료형의 표현가능한 범위를 벗어나는지 확인한다.
    - 너무 큰 결과
    - 너무 큰 중간 값
    - 너무 큰 무한대 값
- 오버플로 피해가기
    - 더 큰 자료형을 쓴다.
    - 연산의 순서를 바꾼다.
## 3.6 실수 자료형의 이해
- 실수 연산의 어려움
- IEEE 754 표준을 이해한다.
    - 이진수를 실수로 표기
    - 부동 소수점(floating-point) 표기법
    - 무한대, 비정규 수(subnormal number), NaN(Not a Number: 숫자 아님) 등의 특수한 값 존재

# 알고리즘의 시간 복잡도 분석
## 4.1 도입
- 실행시간은 수많은 요소가 관여되어 부적합.
### 반복문이 지배한다
- 수행시간을 반복문이 수행되는 수로 측정한다. 
- 반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현.
